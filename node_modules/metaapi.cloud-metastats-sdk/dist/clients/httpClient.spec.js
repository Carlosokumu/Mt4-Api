'use strict';

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _httpClient = require('./httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _errorHandler = require('./errorHandler');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('HttpClient', () => {

  /**
   * @test {HttpClient#request}
   */
  describe('HttpClient#request', () => {

    let httpClient;

    /**
     * @test {HttpClient#request}
     */
    describe('Real request', () => {

      beforeEach(() => {
        httpClient = new _httpClient2.default();
      });

      /**
       * @test {HttpClient#request}
       */
      it('should load HTML page from example.com', async () => {
        const opts = { url: 'http://example.com' };
        const response = await httpClient.request(opts);
        response.should.match(/doctype html/);
      });

      /**
       * @test {HttpClient#request}
       */
      it('should return NotFound error if server returns 404', async () => {
        let opts = { url: 'http://example.com/not-found' };
        try {
          const response = await httpClient.request(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.be.eql('NotFoundError');
        }
      });

      /**
       * @test {HttpClient#request}
       */
      it('should return timeout error if request is timed out', async () => {
        httpClient = new _httpClient2.default(0.001, { retries: 2 });
        let opts = { url: 'http://metaapi.cloud' };
        try {
          const response = await httpClient.request(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.be.eql('ApiError');
          err.message.should.be.eql('ETIMEDOUT');
        }
      }).timeout(10000);
    });

    /**
     * @test {HttpClient#request}
     */
    describe('Retry request', () => {

      const opts = { url: 'http://metaapi.cloud' };
      let sandbox, stub;

      before(() => {
        sandbox = _sinon2.default.createSandbox();
      });

      beforeEach(() => {
        stub = sandbox.stub();
        httpClient = new _httpClient.HttpClientMock(stub);
      });

      afterEach(() => {
        sandbox.restore();
      });

      /**
       * @test {HttpClient#request}
       */
      describe('when status 202 response received', () => {

        /**
         * @test {HttpClient#request}
         */
        it('should wait for the retry-after header time before retrying', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 3 }, statusCode: 202 });
          }).onThirdCall().resolves('response');
          const response = await httpClient.request(opts);
          response.should.eql('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#request}
         */
        it('should return TimeoutError error if retry-after header time is too long', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 30 }, statusCode: 202 });
          });
          httpClient = new _httpClient.HttpClientMock(stub, 60, { maxDelayInSeconds: 3 });
          try {
            await httpClient.request(opts);
            _should2.default.not.exist('Should not exist this assertion');
          } catch (err) {
            err.name.should.eql('TimeoutError');
            err.message.should.eql('Timed out waiting for the end of the process of calculating metrics');
          }
          _sinon2.default.assert.calledOnce(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#request}
         */
        it('should return TimeoutError error if timed out to retry', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 1 }, statusCode: 202 });
          });
          httpClient = new _httpClient.HttpClientMock(stub, 60, { maxDelayInSeconds: 2, retries: 3 });
          try {
            await httpClient.request(opts);
            _should2.default.not.exist('Should not exist this assertion');
          } catch (err) {
            err.name.should.eql('TimeoutError');
            err.message.should.eql('Timed out waiting for the end of the process of calculating metrics');
          }
          _sinon2.default.assert.callCount(stub, 6);
        }).timeout(10000);
      });
    });
  });

  /**
   * @test {HttpClient#requestWithFailover}
   */
  describe('HttpClient#requestWithFailover', () => {

    let httpClient;

    /**
     * @test {HttpClient#requestWithFailover}
     */
    describe('Real request', () => {

      beforeEach(() => {
        httpClient = new _httpClient2.default();
      });

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should load HTML page from example.com', async () => {
        const opts = { url: 'http://example.com' };
        const response = await httpClient.requestWithFailover(opts);
        response.should.match(/doctype html/);
      });

      /**
       * @test {HttpClient#request}
       */
      it('should return NotFound error if server returns 404', async () => {
        let opts = { url: 'http://example.com/not-found' };
        try {
          const response = await httpClient.requestWithFailover(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.be.eql('NotFoundError');
        }
      });

      /**
       * @test {HttpClient#requestWithFailover}
       */
      it('should return timeout error if request is timed out', async () => {
        httpClient = new _httpClient2.default(0.001, { retries: 2 });
        let opts = { url: 'http://metaapi.cloud' };
        try {
          const response = await httpClient.requestWithFailover(opts);
          _should2.default.not.exist(response);
        } catch (err) {
          err.name.should.be.eql('ApiError');
          err.message.should.be.eql('ETIMEDOUT');
        }
      }).timeout(10000);
    });

    /**
     * @test {HttpClient#requestWithFailover}
     */
    describe('Retry request', () => {

      const opts = { url: 'http://metaapi.cloud' };
      let sandbox, stub;

      before(() => {
        sandbox = _sinon2.default.createSandbox();
      });

      beforeEach(() => {
        stub = sandbox.stub();
        httpClient = new _httpClient.HttpClientMock(stub);
      });

      afterEach(() => {
        sandbox.restore();
      });

      /**
       * @test {HttpClient#requestWithFailover}
       */
      describe('when InternalError or ApiError error occured', () => {

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should retry request on fail with ApiError error', async () => {
          stub.onFirstCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onSecondCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onThirdCall().resolves('response');
          const response = await httpClient.requestWithFailover(opts);
          response.should.match('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should retry request on fail with InternalError error', async () => {
          stub.onFirstCall().rejects(new _errorHandler.InternalError('test')).onSecondCall().rejects(new _errorHandler.InternalError('test')).onThirdCall().resolves('response');
          const response = await httpClient.requestWithFailover(opts);
          response.should.match('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should return error if retry limit exceeded', async () => {
          stub.rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test'));
          httpClient = new _httpClient.HttpClientMock(stub, 60, { retries: 2 });
          try {
            const response = await httpClient.requestWithFailover(opts);
            _should2.default.not.exist(response);
          } catch (err) {
            err.name.should.eql('ApiError');
            err.message.should.eql('test');
          }
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should not retry if error is neither InternalError nor ApiError', async () => {
          stub.onFirstCall().rejects(new _errorHandler.ValidationError('test')).onSecondCall().rejects(new _errorHandler.ValidationError('test')).onThirdCall().resolves('response');
          try {
            const response = await httpClient.requestWithFailover(opts);
            _should2.default.not.exist(response);
          } catch (err) {
            err.name.should.eql('ValidationError');
            err.message.should.eql('test');
          }
          _sinon2.default.assert.calledOnce(stub);
        }).timeout(10000);
      });

      /**
       * @test {HttpClient#request}
       */
      describe('when TooManyRequestsError error occured', () => {

        const getTooManyRequestsError = sec => {
          const date = new Date();
          date.setSeconds(date.getSeconds() + sec);
          const recommendedRetryTime = date.toUTCString();
          return new _errorHandler.TooManyRequestsError('test', { recommendedRetryTime });
        };

        /**
         * @test {HttpClient#request}
         */
        it('should retry request after waiting on fail with TooManyRequestsError error', async () => {
          stub.onFirstCall().rejects(getTooManyRequestsError(2)).onSecondCall().rejects(getTooManyRequestsError(3)).onThirdCall().resolves('response');
          const response = await httpClient.requestWithFailover(opts);
          response.should.eql('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#request}
         */
        it('should return error if recommended retry time is too long', async () => {
          stub.onFirstCall().rejects(getTooManyRequestsError(2)).onSecondCall().rejects(getTooManyRequestsError(300)).onThirdCall().resolves('response');
          try {
            const response = await httpClient.requestWithFailover(opts);
            _should2.default.not.exist(response);
          } catch (err) {
            err.name.should.eql('TooManyRequestsError');
            err.message.should.eql('test');
          }
          _sinon2.default.assert.calledTwice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#request}
         */
        it('should not count retrying TooManyRequestsError error', async () => {
          stub.onFirstCall().rejects(getTooManyRequestsError(1)).onSecondCall().rejects(new _errorHandler.ApiError(_errorHandler.ApiError, 'test')).onThirdCall().resolves('response');
          httpClient = new _httpClient.HttpClientMock(stub, 60, { retries: 1 });
          const response = await httpClient.requestWithFailover(opts);
          response.should.eql('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);
      });

      /**
       * @test {HttpClient#requestWithFailover}
       */
      describe('when status 202 response received', () => {

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should wait for the retry-after header time before retrying', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 3 }, statusCode: 202 });
          }).onThirdCall().resolves('response');
          const response = await httpClient.requestWithFailover(opts);
          response.should.eql('response');
          _sinon2.default.assert.calledThrice(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should return TimeoutError error if retry-after header time is too long', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 30 }, statusCode: 202 });
          });
          httpClient = new _httpClient.HttpClientMock(stub, 60, { maxDelayInSeconds: 3 });
          try {
            await httpClient.requestWithFailover(opts);
            _should2.default.not.exist('Should not exist this assertion');
          } catch (err) {
            err.name.should.eql('TimeoutError');
            err.message.should.eql('Timed out waiting for the end of the process of calculating metrics');
          }
          _sinon2.default.assert.calledOnce(stub);
        }).timeout(10000);

        /**
         * @test {HttpClient#requestWithFailover}
         */
        it('should return TimeoutError error if timed out to retry', async () => {
          stub.callsFake(options => {
            options.callback(null, { headers: { 'retry-after': 1 }, statusCode: 202 });
          });
          httpClient = new _httpClient.HttpClientMock(stub, 60, { maxDelayInSeconds: 2, retries: 3 });
          try {
            await httpClient.requestWithFailover(opts);
            _should2.default.not.exist('Should not exist this assertion');
          } catch (err) {
            err.name.should.eql('TimeoutError');
            err.message.should.eql('Timed out waiting for the end of the process of calculating metrics');
          }
          _sinon2.default.assert.callCount(stub, 6);
        }).timeout(10000);
      });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2h0dHBDbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJodHRwQ2xpZW50IiwiYmVmb3JlRWFjaCIsIkh0dHBDbGllbnQiLCJpdCIsIm9wdHMiLCJ1cmwiLCJyZXNwb25zZSIsInJlcXVlc3QiLCJzaG91bGQiLCJtYXRjaCIsIm5vdCIsImV4aXN0IiwiZXJyIiwibmFtZSIsImJlIiwiZXFsIiwicmV0cmllcyIsIm1lc3NhZ2UiLCJ0aW1lb3V0Iiwic2FuZGJveCIsInN0dWIiLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJIdHRwQ2xpZW50TW9jayIsImFmdGVyRWFjaCIsInJlc3RvcmUiLCJjYWxsc0Zha2UiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJoZWFkZXJzIiwic3RhdHVzQ29kZSIsIm9uVGhpcmRDYWxsIiwicmVzb2x2ZXMiLCJhc3NlcnQiLCJjYWxsZWRUaHJpY2UiLCJtYXhEZWxheUluU2Vjb25kcyIsImNhbGxlZE9uY2UiLCJjYWxsQ291bnQiLCJyZXF1ZXN0V2l0aEZhaWxvdmVyIiwib25GaXJzdENhbGwiLCJyZWplY3RzIiwiQXBpRXJyb3IiLCJvblNlY29uZENhbGwiLCJJbnRlcm5hbEVycm9yIiwiVmFsaWRhdGlvbkVycm9yIiwiZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IiLCJzZWMiLCJkYXRlIiwiRGF0ZSIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJ0b1VUQ1N0cmluZyIsIlRvb01hbnlSZXF1ZXN0c0Vycm9yIiwiY2FsbGVkVHdpY2UiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUFBLFNBQVMsWUFBVCxFQUF1QixNQUFNOztBQUUzQjs7O0FBR0FBLFdBQVMsb0JBQVQsRUFBK0IsTUFBTTs7QUFFbkMsUUFBSUMsVUFBSjs7QUFFQTs7O0FBR0FELGFBQVMsY0FBVCxFQUF5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QW1CSixJQUFuQixFQUF5QixFQUF6QixFQUE2QixFQUFDZ0IsbUJBQW1CLENBQXBCLEVBQXVCcEIsU0FBUyxDQUFoQyxFQUE3QixDQUFiO0FBQ0EsY0FBSTtBQUNGLGtCQUFNaEIsV0FBV3VDLG1CQUFYLENBQStCbkMsSUFBL0IsQ0FBTjtBQUNBSSw2QkFBT0UsR0FBUCxDQUFXQyxLQUFYLENBQWlCLGlDQUFqQjtBQUNELFdBSEQsQ0FHRSxPQUFPQyxHQUFQLEVBQVk7QUFDWkEsZ0JBQUlDLElBQUosQ0FBU0wsTUFBVCxDQUFnQk8sR0FBaEIsQ0FBb0IsY0FBcEI7QUFDQUgsZ0JBQUlLLE9BQUosQ0FBWVQsTUFBWixDQUFtQk8sR0FBbkIsQ0FBdUIscUVBQXZCO0FBQ0Q7QUFDRE8sMEJBQU1ZLE1BQU4sQ0FBYUksU0FBYixDQUF1QmxCLElBQXZCLEVBQTZCLENBQTdCO0FBQ0QsU0FiRCxFQWFHRixPQWJILENBYVcsS0FiWDtBQWVELE9BbEREO0FBb0RELEtBak1EO0FBbU1ELEdBMVBEO0FBNFBELENBeFlEIiwiZmlsZSI6Imh0dHBDbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNob3VsZCBmcm9tICdzaG91bGQnO1xuaW1wb3J0IHNpbm9uICBmcm9tICdzaW5vbic7XG5pbXBvcnQgSHR0cENsaWVudCwge0h0dHBDbGllbnRNb2NrfSBmcm9tICcuL2h0dHBDbGllbnQnO1xuaW1wb3J0IHtWYWxpZGF0aW9uRXJyb3IsIEFwaUVycm9yLCBJbnRlcm5hbEVycm9yLCBUb29NYW55UmVxdWVzdHNFcnJvcn0gZnJvbSAnLi9lcnJvckhhbmRsZXInO1xuXG5kZXNjcmliZSgnSHR0cENsaWVudCcsICgpID0+IHtcblxuICAvKipcbiAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICovXG4gIGRlc2NyaWJlKCdIdHRwQ2xpZW50I3JlcXVlc3QnLCAoKSA9PiB7XG5cbiAgICBsZXQgaHR0cENsaWVudDtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3R9XG4gICAgICovXG4gICAgZGVzY3JpYmUoJ1JlYWwgcmVxdWVzdCcsICgpID0+IHtcblxuICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCBsb2FkIEhUTUwgcGFnZSBmcm9tIGV4YW1wbGUuY29tJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRzID0ge3VybDogJ2h0dHA6Ly9leGFtcGxlLmNvbSd9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdChvcHRzKTtcbiAgICAgICAgcmVzcG9uc2Uuc2hvdWxkLm1hdGNoKC9kb2N0eXBlIGh0bWwvKTtcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3R9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIE5vdEZvdW5kIGVycm9yIGlmIHNlcnZlciByZXR1cm5zIDQwNCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IG9wdHMgPSB7dXJsOiAnaHR0cDovL2V4YW1wbGUuY29tL25vdC1mb3VuZCd9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnIubmFtZS5zaG91bGQuYmUuZXFsKCdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3R9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRpbWVvdXQgZXJyb3IgaWYgcmVxdWVzdCBpcyB0aW1lZCBvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgwLjAwMSwge3JldHJpZXM6IDJ9KTtcbiAgICAgICAgbGV0IG9wdHMgPSB7dXJsOiAnaHR0cDovL21ldGFhcGkuY2xvdWQnfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICBzaG91bGQubm90LmV4aXN0KHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmJlLmVxbCgnQXBpRXJyb3InKTtcbiAgICAgICAgICBlcnIubWVzc2FnZS5zaG91bGQuYmUuZXFsKCdFVElNRURPVVQnKTtcbiAgICAgICAgfVxuICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3R9XG4gICAgICovXG4gICAgZGVzY3JpYmUoJ1JldHJ5IHJlcXVlc3QnLCAoKSA9PiB7XG5cbiAgICAgIGNvbnN0IG9wdHMgPSB7dXJsOiAnaHR0cDovL21ldGFhcGkuY2xvdWQnfTtcbiAgICAgIGxldCBzYW5kYm94LCBzdHViO1xuXG4gICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICBzYW5kYm94ID0gc2lub24uY3JlYXRlU2FuZGJveCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBzdHViID0gc2FuZGJveC5zdHViKCk7XG4gICAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudE1vY2soc3R1Yik7XG4gICAgICB9KTtcblxuICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICovXG4gICAgICBkZXNjcmliZSgnd2hlbiBzdGF0dXMgMjAyIHJlc3BvbnNlIHJlY2VpdmVkJywgKCkgPT4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgaXQoJ3Nob3VsZCB3YWl0IGZvciB0aGUgcmV0cnktYWZ0ZXIgaGVhZGVyIHRpbWUgYmVmb3JlIHJldHJ5aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHN0dWIuY2FsbHNGYWtlKChvcHRpb25zKT0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwge2hlYWRlcnM6IHsncmV0cnktYWZ0ZXInOiAzfSwgc3RhdHVzQ29kZTogMjAyfSk7XG4gICAgICAgICAgfSkub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICByZXNwb25zZS5zaG91bGQuZXFsKCdyZXNwb25zZScpO1xuICAgICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUaHJpY2Uoc3R1Yik7XG4gICAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gVGltZW91dEVycm9yIGVycm9yIGlmIHJldHJ5LWFmdGVyIGhlYWRlciB0aW1lIGlzIHRvbyBsb25nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHN0dWIuY2FsbHNGYWtlKChvcHRpb25zKT0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwge2hlYWRlcnM6IHsncmV0cnktYWZ0ZXInOiAzMH0sIHN0YXR1c0NvZGU6IDIwMn0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudE1vY2soc3R1YiwgNjAsIHttYXhEZWxheUluU2Vjb25kczogM30pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICBzaG91bGQubm90LmV4aXN0KCdTaG91bGQgbm90IGV4aXN0IHRoaXMgYXNzZXJ0aW9uJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubmFtZS5zaG91bGQuZXFsKCdUaW1lb3V0RXJyb3InKTtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcWwoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzIG9mIGNhbGN1bGF0aW5nIG1ldHJpY3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2Uoc3R1Yik7XG4gICAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gVGltZW91dEVycm9yIGVycm9yIGlmIHRpbWVkIG91dCB0byByZXRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzdHViLmNhbGxzRmFrZSgob3B0aW9ucyk9PiB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIHtoZWFkZXJzOiB7J3JldHJ5LWFmdGVyJzogMX0sIHN0YXR1c0NvZGU6IDIwMn0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudE1vY2soc3R1YiwgNjAsIHttYXhEZWxheUluU2Vjb25kczogMiwgcmV0cmllczogM30pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICBzaG91bGQubm90LmV4aXN0KCdTaG91bGQgbm90IGV4aXN0IHRoaXMgYXNzZXJ0aW9uJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubmFtZS5zaG91bGQuZXFsKCdUaW1lb3V0RXJyb3InKTtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcWwoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzIG9mIGNhbGN1bGF0aW5nIG1ldHJpY3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxDb3VudChzdHViLCA2KTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAqL1xuICBkZXNjcmliZSgnSHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyJywgKCkgPT4ge1xuXG4gICAgbGV0IGh0dHBDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAqL1xuICAgIGRlc2NyaWJlKCdSZWFsIHJlcXVlc3QnLCAoKSA9PiB7XG5cbiAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgbG9hZCBIVE1MIHBhZ2UgZnJvbSBleGFtcGxlLmNvbScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt1cmw6ICdodHRwOi8vZXhhbXBsZS5jb20nfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgIHJlc3BvbnNlLnNob3VsZC5tYXRjaCgvZG9jdHlwZSBodG1sLyk7XG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBOb3RGb3VuZCBlcnJvciBpZiBzZXJ2ZXIgcmV0dXJucyA0MDQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBvcHRzID0ge3VybDogJ2h0dHA6Ly9leGFtcGxlLmNvbS9ub3QtZm91bmQnfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICBzaG91bGQubm90LmV4aXN0KHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmJlLmVxbCgnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiB0aW1lb3V0IGVycm9yIGlmIHJlcXVlc3QgaXMgdGltZWQgb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoMC4wMDEsIHtyZXRyaWVzOiAyfSk7XG4gICAgICAgIGxldCBvcHRzID0ge3VybDogJ2h0dHA6Ly9tZXRhYXBpLmNsb3VkJ307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgICAgc2hvdWxkLm5vdC5leGlzdChyZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5iZS5lcWwoJ0FwaUVycm9yJyk7XG4gICAgICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmJlLmVxbCgnRVRJTUVET1VUJyk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAqL1xuICAgIGRlc2NyaWJlKCdSZXRyeSByZXF1ZXN0JywgKCkgPT4ge1xuXG4gICAgICBjb25zdCBvcHRzID0ge3VybDogJ2h0dHA6Ly9tZXRhYXBpLmNsb3VkJ307XG4gICAgICBsZXQgc2FuZGJveCwgc3R1YjtcblxuICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgICAgIH0pO1xuXG4gICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgc3R1YiA9IHNhbmRib3guc3R1YigpO1xuICAgICAgICBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnRNb2NrKHN0dWIpO1xuICAgICAgfSk7XG5cbiAgICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIHNhbmRib3gucmVzdG9yZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdFdpdGhGYWlsb3Zlcn1cbiAgICAgICAqL1xuICAgICAgZGVzY3JpYmUoJ3doZW4gSW50ZXJuYWxFcnJvciBvciBBcGlFcnJvciBlcnJvciBvY2N1cmVkJywgKCkgPT4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0V2l0aEZhaWxvdmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgaXQoJ3Nob3VsZCByZXRyeSByZXF1ZXN0IG9uIGZhaWwgd2l0aCBBcGlFcnJvciBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzdHViLm9uRmlyc3RDYWxsKCkucmVqZWN0cyhuZXcgQXBpRXJyb3IoQXBpRXJyb3IsICd0ZXN0JykpXG4gICAgICAgICAgICAub25TZWNvbmRDYWxsKCkucmVqZWN0cyhuZXcgQXBpRXJyb3IoQXBpRXJyb3IsICd0ZXN0JykpXG4gICAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICByZXNwb25zZS5zaG91bGQubWF0Y2goJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIHJldHJ5IHJlcXVlc3Qgb24gZmFpbCB3aXRoIEludGVybmFsRXJyb3IgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgc3R1Yi5vbkZpcnN0Q2FsbCgpLnJlamVjdHMobmV3IEludGVybmFsRXJyb3IoJ3Rlc3QnKSlcbiAgICAgICAgICAgIC5vblNlY29uZENhbGwoKS5yZWplY3RzKG5ldyBJbnRlcm5hbEVycm9yKCd0ZXN0JykpXG4gICAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICByZXNwb25zZS5zaG91bGQubWF0Y2goJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBlcnJvciBpZiByZXRyeSBsaW1pdCBleGNlZWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzdHViLnJlamVjdHMobmV3IEFwaUVycm9yKEFwaUVycm9yLCAndGVzdCcpKTtcbiAgICAgICAgICBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnRNb2NrKHN0dWIsIDYwLCB7cmV0cmllczogMn0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxbCgnQXBpRXJyb3InKTtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcWwoJ3Rlc3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSBpZiBlcnJvciBpcyBuZWl0aGVyIEludGVybmFsRXJyb3Igbm9yIEFwaUVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHN0dWIub25GaXJzdENhbGwoKS5yZWplY3RzKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Rlc3QnKSlcbiAgICAgICAgICAgIC5vblNlY29uZENhbGwoKS5yZWplY3RzKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Rlc3QnKSlcbiAgICAgICAgICAgIC5vblRoaXJkQ2FsbCgpLnJlc29sdmVzKCdyZXNwb25zZScpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QocmVzcG9uc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxbCgnVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICAgICAgICBlcnIubWVzc2FnZS5zaG91bGQuZXFsKCd0ZXN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKHN0dWIpO1xuICAgICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICAgICAqL1xuICAgICAgZGVzY3JpYmUoJ3doZW4gVG9vTWFueVJlcXVlc3RzRXJyb3IgZXJyb3Igb2NjdXJlZCcsICgpID0+IHtcblxuICAgICAgICBjb25zdCBnZXRUb29NYW55UmVxdWVzdHNFcnJvciA9IChzZWMpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBkYXRlLnNldFNlY29uZHMoZGF0ZS5nZXRTZWNvbmRzKCkgKyBzZWMpO1xuICAgICAgICAgIGNvbnN0IHJlY29tbWVuZGVkUmV0cnlUaW1lID0gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoJ3Rlc3QnLCB7cmVjb21tZW5kZWRSZXRyeVRpbWV9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICAgICAgICovXG4gICAgICAgIGl0KCdzaG91bGQgcmV0cnkgcmVxdWVzdCBhZnRlciB3YWl0aW5nIG9uIGZhaWwgd2l0aCBUb29NYW55UmVxdWVzdHNFcnJvciBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBzdHViLm9uRmlyc3RDYWxsKCkucmVqZWN0cyhnZXRUb29NYW55UmVxdWVzdHNFcnJvcigyKSlcbiAgICAgICAgICAgIC5vblNlY29uZENhbGwoKS5yZWplY3RzKGdldFRvb01hbnlSZXF1ZXN0c0Vycm9yKDMpKVxuICAgICAgICAgICAgLm9uVGhpcmRDYWxsKCkucmVzb2x2ZXMoJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RXaXRoRmFpbG92ZXIob3B0cyk7XG4gICAgICAgICAgcmVzcG9uc2Uuc2hvdWxkLmVxbCgncmVzcG9uc2UnKTtcbiAgICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVGhyaWNlKHN0dWIpO1xuICAgICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHRlc3Qge0h0dHBDbGllbnQjcmVxdWVzdH1cbiAgICAgICAgICovXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIGlmIHJlY29tbWVuZGVkIHJldHJ5IHRpbWUgaXMgdG9vIGxvbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgc3R1Yi5vbkZpcnN0Q2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMikpXG4gICAgICAgICAgICAub25TZWNvbmRDYWxsKCkucmVqZWN0cyhnZXRUb29NYW55UmVxdWVzdHNFcnJvcigzMDApKVxuICAgICAgICAgICAgLm9uVGhpcmRDYWxsKCkucmVzb2x2ZXMoJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICAgICAgc2hvdWxkLm5vdC5leGlzdChyZXNwb25zZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubmFtZS5zaG91bGQuZXFsKCdUb29NYW55UmVxdWVzdHNFcnJvcicpO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxbCgndGVzdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVHdpY2Uoc3R1Yik7XG4gICAgICAgIH0pLnRpbWVvdXQoMTAwMDApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGVzdCB7SHR0cENsaWVudCNyZXF1ZXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgaXQoJ3Nob3VsZCBub3QgY291bnQgcmV0cnlpbmcgVG9vTWFueVJlcXVlc3RzRXJyb3IgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgc3R1Yi5vbkZpcnN0Q2FsbCgpLnJlamVjdHMoZ2V0VG9vTWFueVJlcXVlc3RzRXJyb3IoMSkpXG4gICAgICAgICAgICAub25TZWNvbmRDYWxsKCkucmVqZWN0cyhuZXcgQXBpRXJyb3IoQXBpRXJyb3IsICd0ZXN0JykpXG4gICAgICAgICAgICAub25UaGlyZENhbGwoKS5yZXNvbHZlcygncmVzcG9uc2UnKTtcbiAgICAgICAgICBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnRNb2NrKHN0dWIsIDYwLCB7cmV0cmllczogMX0pO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICAgIHJlc3BvbnNlLnNob3VsZC5lcWwoJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgKi9cbiAgICAgIGRlc2NyaWJlKCd3aGVuIHN0YXR1cyAyMDIgcmVzcG9uc2UgcmVjZWl2ZWQnLCAoKSA9PiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIHdhaXQgZm9yIHRoZSByZXRyeS1hZnRlciBoZWFkZXIgdGltZSBiZWZvcmUgcmV0cnlpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgc3R1Yi5jYWxsc0Zha2UoKG9wdGlvbnMpPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCB7aGVhZGVyczogeydyZXRyeS1hZnRlcic6IDN9LCBzdGF0dXNDb2RlOiAyMDJ9KTtcbiAgICAgICAgICB9KS5vblRoaXJkQ2FsbCgpLnJlc29sdmVzKCdyZXNwb25zZScpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yZXF1ZXN0V2l0aEZhaWxvdmVyKG9wdHMpO1xuICAgICAgICAgIHJlc3BvbnNlLnNob3VsZC5lcWwoJ3Jlc3BvbnNlJyk7XG4gICAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFRocmljZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBUaW1lb3V0RXJyb3IgZXJyb3IgaWYgcmV0cnktYWZ0ZXIgaGVhZGVyIHRpbWUgaXMgdG9vIGxvbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgc3R1Yi5jYWxsc0Zha2UoKG9wdGlvbnMpPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCB7aGVhZGVyczogeydyZXRyeS1hZnRlcic6IDMwfSwgc3RhdHVzQ29kZTogMjAyfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCA2MCwge21heERlbGF5SW5TZWNvbmRzOiAzfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QoJ1Nob3VsZCBub3QgZXhpc3QgdGhpcyBhc3NlcnRpb24nKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5lcWwoJ1RpbWVvdXRFcnJvcicpO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxbCgnVGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSBlbmQgb2YgdGhlIHByb2Nlc3Mgb2YgY2FsY3VsYXRpbmcgbWV0cmljcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShzdHViKTtcbiAgICAgICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0ZXN0IHtIdHRwQ2xpZW50I3JlcXVlc3RXaXRoRmFpbG92ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBUaW1lb3V0RXJyb3IgZXJyb3IgaWYgdGltZWQgb3V0IHRvIHJldHJ5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHN0dWIuY2FsbHNGYWtlKChvcHRpb25zKT0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwge2hlYWRlcnM6IHsncmV0cnktYWZ0ZXInOiAxfSwgc3RhdHVzQ29kZTogMjAyfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50TW9jayhzdHViLCA2MCwge21heERlbGF5SW5TZWNvbmRzOiAyLCByZXRyaWVzOiAzfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdFdpdGhGYWlsb3ZlcihvcHRzKTtcbiAgICAgICAgICAgIHNob3VsZC5ub3QuZXhpc3QoJ1Nob3VsZCBub3QgZXhpc3QgdGhpcyBhc3NlcnRpb24nKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5uYW1lLnNob3VsZC5lcWwoJ1RpbWVvdXRFcnJvcicpO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxbCgnVGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSBlbmQgb2YgdGhlIHByb2Nlc3Mgb2YgY2FsY3VsYXRpbmcgbWV0cmljcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KHN0dWIsIDYpO1xuICAgICAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICB9KTtcblxufSk7Il19