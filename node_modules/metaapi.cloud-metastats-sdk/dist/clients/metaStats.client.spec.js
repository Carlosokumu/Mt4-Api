'use strict';

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _metaStats = require('./metaStats.client');

var _metaStats2 = _interopRequireDefault(_metaStats);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @test {MetaStatsClient}
 */
describe('MetaStatsClient', () => {

  const accountId = '1234567';
  const token = 'token.payload.sign';
  const host = 'agiliumtrade.ai';
  const domainClient = {
    requestMetastats: () => {},
    token: token
  };
  let metaStatsClient, sandbox, requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    metaStatsClient = new _metaStats2.default(domainClient);
    requestStub = sandbox.stub(domainClient, 'requestMetastats');
  });

  afterEach(() => {
    sandbox.resetHistory();
    sandbox.restore();
  });

  /**
   * @test {MetaStatsClient#getMetrics}
   */
  describe('MetaStatsClient#getMetrics', () => {

    const expected = { trades: 10, equity: 10102.5, balance: 10105, profit: 104, deposits: 10001 };

    beforeEach(() => {
      requestStub.resolves({ metrics: expected });
    });

    /**
     * @test {MetaStatsClient#getMetrics}
     */
    it('should retrieve account metrics from API', async () => {
      const metrics = await metaStatsClient.getMetrics(accountId);
      metrics.should.be.eql(expected);
      const args = requestStub.getCall(0).args;
      _sinon2.default.assert.match(args[0](host, accountId), { url: 'agiliumtrade.ai/users/current/accounts/1234567/metrics',
        method: 'GET',
        headers: { 'auth-token': token },
        json: true,
        qs: { includeOpenPositions: false }
      });
      _sinon2.default.assert.match(args[1], '1234567');
    });

    /**
     * @test {MetaStatsClient#getMetrics}
     */
    it('should retrieve account metrics with included open positions from API', async () => {
      expected.inclusive = false;
      const metrics = await metaStatsClient.getMetrics(accountId, true);
      metrics.should.be.eql(expected);
      const args = requestStub.getCall(0).args;
      _sinon2.default.assert.match(args[0](host, accountId), { url: 'agiliumtrade.ai/users/current/accounts/1234567/metrics',
        method: 'GET',
        headers: { 'auth-token': token },
        json: true,
        qs: { includeOpenPositions: true }
      });
      _sinon2.default.assert.match(args[1], '1234567');
    });
  });

  /**
   * @test {MetaStatsClient#getAccountTrades}
   */
  describe('MetaStatsClient#getAccountTrades', () => {
    const expected = [{ _id: '1' }];
    const startTime = '2020-01-01 00:00:00.000';
    const endTime = '2021-01-01 00:00:00.000';

    beforeEach(() => {
      requestStub.resolves({ trades: expected });
    });

    /**
     * @test {MetaStatsClient#getAccountTrades}
     */
    it('should retrieve account trades from API', async () => {
      const trades = await metaStatsClient.getAccountTrades(accountId, startTime, endTime);
      trades.should.be.eql(expected);
      const args = requestStub.getCall(0).args;
      _sinon2.default.assert.match(args[0](host, accountId), { url: `agiliumtrade.ai/users/current/accounts/1234567/historical-trades/${startTime}/${endTime}`,
        method: 'GET',
        headers: { 'auth-token': token },
        json: true,
        qs: { updateHistory: true, limit: 1000, offset: 0 }
      });
      _sinon2.default.assert.match(args[1], '1234567');
    });
  });

  /**
   * @test {MetaStatsClient#getOpenTrades}
   */
  describe('MetaStatsClient#getOpenTrades', () => {
    const expected = [{ _id: '1' }];

    beforeEach(() => {
      requestStub.resolves({ openTrades: expected });
    });

    /**
     * @test {MetaStatsClient#getOpenTrades}
     */
    it('should retrieve account open trades from API', async () => {
      const openTrades = await metaStatsClient.getAccountOpenTrades(accountId);
      openTrades.should.be.eql(expected);
      const args = requestStub.getCall(0).args;
      _sinon2.default.assert.match(args[0](host, accountId), { url: 'agiliumtrade.ai/users/current/accounts/1234567/open-trades',
        method: 'GET',
        headers: { 'auth-token': token },
        json: true
      });
      _sinon2.default.assert.match(args[1], '1234567');
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL21ldGFTdGF0cy5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJhY2NvdW50SWQiLCJ0b2tlbiIsImhvc3QiLCJkb21haW5DbGllbnQiLCJyZXF1ZXN0TWV0YXN0YXRzIiwibWV0YVN0YXRzQ2xpZW50Iiwic2FuZGJveCIsInJlcXVlc3RTdHViIiwiYmVmb3JlIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwiYmVmb3JlRWFjaCIsIk1ldGFTdGF0c0NsaWVudCIsInN0dWIiLCJhZnRlckVhY2giLCJyZXNldEhpc3RvcnkiLCJyZXN0b3JlIiwiZXhwZWN0ZWQiLCJ0cmFkZXMiLCJlcXVpdHkiLCJiYWxhbmNlIiwicHJvZml0IiwiZGVwb3NpdHMiLCJyZXNvbHZlcyIsIm1ldHJpY3MiLCJpdCIsImdldE1ldHJpY3MiLCJzaG91bGQiLCJiZSIsImVxbCIsImFyZ3MiLCJnZXRDYWxsIiwiYXNzZXJ0IiwibWF0Y2giLCJ1cmwiLCJtZXRob2QiLCJoZWFkZXJzIiwianNvbiIsInFzIiwiaW5jbHVkZU9wZW5Qb3NpdGlvbnMiLCJpbmNsdXNpdmUiLCJfaWQiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZ2V0QWNjb3VudFRyYWRlcyIsInVwZGF0ZUhpc3RvcnkiLCJsaW1pdCIsIm9mZnNldCIsIm9wZW5UcmFkZXMiLCJnZXRBY2NvdW50T3BlblRyYWRlcyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7O0FBR0FBLFNBQVMsaUJBQVQsRUFBNEIsTUFBTTs7QUFFaEMsUUFBTUMsWUFBWSxTQUFsQjtBQUNBLFFBQU1DLFFBQVEsb0JBQWQ7QUFDQSxRQUFNQyxPQUFPLGlCQUFiO0FBQ0EsUUFBTUMsZUFBZTtBQUNuQkMsc0JBQWtCLE1BQU0sQ0FBRSxDQURQO0FBRW5CSCxXQUFPQTtBQUZZLEdBQXJCO0FBSUEsTUFBSUksZUFBSixFQUFxQkMsT0FBckIsRUFBOEJDLFdBQTlC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QUFiLENBQW1CSCxLQUFLLENBQUwsRUFBUTVCLElBQVIsRUFBY0YsU0FBZCxDQUFuQixFQUNFLEVBQUNrQyxLQUFLLDREQUFOO0FBQ0VDLGdCQUFRLEtBRFY7QUFFRUMsaUJBQVMsRUFBQyxjQUFjbkMsS0FBZixFQUZYO0FBR0VvQyxjQUFNO0FBSFIsT0FERjtBQU9BNUIsc0JBQU11QixNQUFOLENBQWFDLEtBQWIsQ0FBbUJILEtBQUssQ0FBTCxDQUFuQixFQUE0QixTQUE1QjtBQUNELEtBWkQ7QUFhRCxHQXZCRDtBQXdCRCxDQXJJRCIsImZpbGUiOiJtZXRhU3RhdHMuY2xpZW50LnNwZWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBzaG91bGQgZnJvbSAnc2hvdWxkJztcbmltcG9ydCBzaW5vbiAgZnJvbSAnc2lub24nO1xuaW1wb3J0IE1ldGFTdGF0c0NsaWVudCBmcm9tICcuL21ldGFTdGF0cy5jbGllbnQnO1xuXG4vKipcbiAqIEB0ZXN0IHtNZXRhU3RhdHNDbGllbnR9XG4gKi9cbmRlc2NyaWJlKCdNZXRhU3RhdHNDbGllbnQnLCAoKSA9PiB7XG4gIFxuICBjb25zdCBhY2NvdW50SWQgPSAnMTIzNDU2Nyc7XG4gIGNvbnN0IHRva2VuID0gJ3Rva2VuLnBheWxvYWQuc2lnbic7XG4gIGNvbnN0IGhvc3QgPSAnYWdpbGl1bXRyYWRlLmFpJztcbiAgY29uc3QgZG9tYWluQ2xpZW50ID0ge1xuICAgIHJlcXVlc3RNZXRhc3RhdHM6ICgpID0+IHt9LFxuICAgIHRva2VuOiB0b2tlblxuICB9O1xuICBsZXQgbWV0YVN0YXRzQ2xpZW50LCBzYW5kYm94LCByZXF1ZXN0U3R1YjtcblxuICBiZWZvcmUoKCkgPT4ge1xuICAgIHNhbmRib3ggPSBzaW5vbi5jcmVhdGVTYW5kYm94KCk7XG4gIH0pO1xuICBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbWV0YVN0YXRzQ2xpZW50ID0gbmV3IE1ldGFTdGF0c0NsaWVudChkb21haW5DbGllbnQpO1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGRvbWFpbkNsaWVudCwgJ3JlcXVlc3RNZXRhc3RhdHMnKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBzYW5kYm94LnJlc2V0SGlzdG9yeSgpO1xuICAgIHNhbmRib3gucmVzdG9yZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFTdGF0c0NsaWVudCNnZXRNZXRyaWNzfVxuICAgKi9cbiAgZGVzY3JpYmUoJ01ldGFTdGF0c0NsaWVudCNnZXRNZXRyaWNzJywgKCkgPT4ge1xuXG4gICAgY29uc3QgZXhwZWN0ZWQgPSB7dHJhZGVzOiAxMCwgZXF1aXR5OiAxMDEwMi41LCBiYWxhbmNlOiAxMDEwNSwgcHJvZml0OiAxMDQsIGRlcG9zaXRzOiAxMDAwMX07XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKHttZXRyaWNzOiBleHBlY3RlZH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFTdGF0c0NsaWVudCNnZXRNZXRyaWNzfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0cmlldmUgYWNjb3VudCBtZXRyaWNzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljcyA9IGF3YWl0IG1ldGFTdGF0c0NsaWVudC5nZXRNZXRyaWNzKGFjY291bnRJZCk7XG4gICAgICBtZXRyaWNzLnNob3VsZC5iZS5lcWwoZXhwZWN0ZWQpO1xuICAgICAgY29uc3QgYXJncyA9IHJlcXVlc3RTdHViLmdldENhbGwoMCkuYXJncztcbiAgICAgIHNpbm9uLmFzc2VydC5tYXRjaChhcmdzWzBdKGhvc3QsIGFjY291bnRJZCksXG4gICAgICAgIHt1cmw6ICdhZ2lsaXVtdHJhZGUuYWkvdXNlcnMvY3VycmVudC9hY2NvdW50cy8xMjM0NTY3L21ldHJpY3MnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeydhdXRoLXRva2VuJzogdG9rZW59LFxuICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgcXM6IHtpbmNsdWRlT3BlblBvc2l0aW9uczogZmFsc2V9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBzaW5vbi5hc3NlcnQubWF0Y2goYXJnc1sxXSwgJzEyMzQ1NjcnKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhU3RhdHNDbGllbnQjZ2V0TWV0cmljc31cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHJpZXZlIGFjY291bnQgbWV0cmljcyB3aXRoIGluY2x1ZGVkIG9wZW4gcG9zaXRpb25zIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0ZWQuaW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICBjb25zdCBtZXRyaWNzID0gYXdhaXQgbWV0YVN0YXRzQ2xpZW50LmdldE1ldHJpY3MoYWNjb3VudElkLCB0cnVlKTtcbiAgICAgIG1ldHJpY3Muc2hvdWxkLmJlLmVxbChleHBlY3RlZCk7XG4gICAgICBjb25zdCBhcmdzID0gcmVxdWVzdFN0dWIuZ2V0Q2FsbCgwKS5hcmdzO1xuICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKGFyZ3NbMF0oaG9zdCwgYWNjb3VudElkKSxcbiAgICAgICAge3VybDogJ2FnaWxpdW10cmFkZS5haS91c2Vycy9jdXJyZW50L2FjY291bnRzLzEyMzQ1NjcvbWV0cmljcycsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7J2F1dGgtdG9rZW4nOiB0b2tlbn0sXG4gICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICBxczoge2luY2x1ZGVPcGVuUG9zaXRpb25zOiB0cnVlfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKGFyZ3NbMV0sICcxMjM0NTY3Jyk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhU3RhdHNDbGllbnQjZ2V0QWNjb3VudFRyYWRlc31cbiAgICovXG4gIGRlc2NyaWJlKCdNZXRhU3RhdHNDbGllbnQjZ2V0QWNjb3VudFRyYWRlcycsICgpID0+IHtcbiAgICBjb25zdCBleHBlY3RlZCA9IFt7X2lkOiAnMSd9XTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSAnMjAyMC0wMS0wMSAwMDowMDowMC4wMDAnO1xuICAgIGNvbnN0IGVuZFRpbWUgPSAnMjAyMS0wMS0wMSAwMDowMDowMC4wMDAnO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyh7dHJhZGVzOiBleHBlY3RlZH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFTdGF0c0NsaWVudCNnZXRBY2NvdW50VHJhZGVzfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0cmlldmUgYWNjb3VudCB0cmFkZXMgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFkZXMgPSBhd2FpdCBtZXRhU3RhdHNDbGllbnQuZ2V0QWNjb3VudFRyYWRlcyhhY2NvdW50SWQsIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICB0cmFkZXMuc2hvdWxkLmJlLmVxbChleHBlY3RlZCk7XG4gICAgICBjb25zdCBhcmdzID0gcmVxdWVzdFN0dWIuZ2V0Q2FsbCgwKS5hcmdzO1xuICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKGFyZ3NbMF0oaG9zdCwgYWNjb3VudElkKSxcbiAgICAgICAge3VybDogYGFnaWxpdW10cmFkZS5haS91c2Vycy9jdXJyZW50L2FjY291bnRzLzEyMzQ1NjcvaGlzdG9yaWNhbC10cmFkZXMvJHtzdGFydFRpbWV9LyR7ZW5kVGltZX1gLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeydhdXRoLXRva2VuJzogdG9rZW59LFxuICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgcXM6IHt1cGRhdGVIaXN0b3J5OiB0cnVlLCBsaW1pdDogMTAwMCwgb2Zmc2V0OiAwfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKGFyZ3NbMV0sICcxMjM0NTY3Jyk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhU3RhdHNDbGllbnQjZ2V0T3BlblRyYWRlc31cbiAgICovXG4gIGRlc2NyaWJlKCdNZXRhU3RhdHNDbGllbnQjZ2V0T3BlblRyYWRlcycsICgpID0+IHtcbiAgICBjb25zdCBleHBlY3RlZCA9IFt7X2lkOiAnMSd9XTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoe29wZW5UcmFkZXM6IGV4cGVjdGVkfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YVN0YXRzQ2xpZW50I2dldE9wZW5UcmFkZXN9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBhY2NvdW50IG9wZW4gdHJhZGVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlblRyYWRlcyA9IGF3YWl0IG1ldGFTdGF0c0NsaWVudC5nZXRBY2NvdW50T3BlblRyYWRlcyhhY2NvdW50SWQpO1xuICAgICAgb3BlblRyYWRlcy5zaG91bGQuYmUuZXFsKGV4cGVjdGVkKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSByZXF1ZXN0U3R1Yi5nZXRDYWxsKDApLmFyZ3M7XG4gICAgICBzaW5vbi5hc3NlcnQubWF0Y2goYXJnc1swXShob3N0LCBhY2NvdW50SWQpLFxuICAgICAgICB7dXJsOiAnYWdpbGl1bXRyYWRlLmFpL3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvMTIzNDU2Ny9vcGVuLXRyYWRlcycsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7J2F1dGgtdG9rZW4nOiB0b2tlbn0sXG4gICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHNpbm9uLmFzc2VydC5tYXRjaChhcmdzWzFdLCAnMTIzNDU2NycpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19