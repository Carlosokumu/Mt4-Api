'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _httpClient = require('./httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _domain = require('./domain.client');

var _domain2 = _interopRequireDefault(_domain);

var _errorHandler = require('./errorHandler');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @test {DomainClient}
 */
describe('DomainClient', () => {

  let domainClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let sandbox;
  let requestStub;
  let getRegionsStub;
  let getHostStub;
  let failoverRequestStub;
  let getAccountStub;
  let clock;
  const expected = { trades: 10, equity: 10102.5, balance: 10105, profit: 104, deposits: 10001 };
  const getOpts = (host, id) => ({
    url: host + `/users/current/accounts/${id}/open-trades`,
    method: 'GET',
    headers: {
      'auth-token': token
    },
    json: true
  });

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    domainClient = new _domain2.default(httpClient, token);
    clock = sandbox.useFakeTimers({ shouldAdvanceTime: true });
    failoverRequestStub = sandbox.stub(httpClient, 'requestWithFailover');
    getAccountStub = failoverRequestStub.withArgs({
      url: 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai/users/current/accounts/accountId',
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    }).resolves({ _id: 'accountId', region: 'vint-hill', state: 'DEPLOYED',
      accountReplicas: [{ _id: 'accountId2', region: 'us-west', state: 'DEPLOYED' }] });
    requestStub = sandbox.stub(httpClient, 'request');
    requestStub.withArgs({
      url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
      method: 'GET',
      headers: { 'auth-token': token },
      json: true
    }).resolves(expected);
    getHostStub = failoverRequestStub.withArgs({
      url: 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai/users/current/servers/mt-client-api',
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    }).resolves({ domain: 'agiliumtrade.ai' });
  });

  afterEach(() => {
    sandbox.restore();
    clock.restore();
  });

  /**
   * @test {DomainClient#requestMetastats}
   */
  describe('requestMetastats', () => {

    const opts = {
      url: '/users/current/accounts/accountId/metrics',
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    };

    /**
     * @test {DomainClient#requestMetastats}
     */
    it('should execute request', async () => {
      const response = await domainClient.requestMetastats(getOpts, 'accountId');
      _sinon2.default.assert.match(response, expected);
      _sinon2.default.assert.calledWith(requestStub, {
        url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
        method: 'GET',
        headers: { 'auth-token': token },
        json: true
      });
    });

    describe('_updateHost', () => {

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should request url again if expired', async () => {
        await domainClient.requestMetastats(getOpts, 'accountId');
        await clock.tickAsync(610000);
        const response = await domainClient.requestMetastats(getOpts, 'accountId');
        _sinon2.default.assert.match(response, expected);
        _sinon2.default.assert.calledWith(requestStub, {
          url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        });
        _sinon2.default.assert.calledTwice(getHostStub);
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should use cached url on repeated request', async () => {
        await domainClient.requestMetastats(getOpts, 'accountId');
        const response = await domainClient.requestMetastats(getOpts, 'accountId');
        _sinon2.default.assert.calledWith(requestStub, {
          url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        });
        _sinon2.default.assert.match(response, expected);
        _sinon2.default.assert.calledOnce(getHostStub);
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should return error if failed to get host', async () => {
        getHostStub.throws(new _errorHandler.ValidationError('test'));
        try {
          await domainClient.requestMetastats(getOpts, 'accountId');
          throw new Error('ValidationError expected');
        } catch (error) {
          error.name.should.equal('ValidationError');
        }
      });
    });

    /**
     * @test {DomainClient#requestMetastats}
     */
    describe('_updateAccountHost', () => {

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should return error if failed to get account data', async () => {
        getAccountStub.rejects(new _errorHandler.ValidationError('test'));
        try {
          await domainClient.requestMetastats(getOpts, 'accountId');
          throw new Error('ValidationError expected');
        } catch (error) {
          error.name.should.equal('ValidationError');
        }
      });

      it('should request main account if using replica', async () => {
        failoverRequestStub.withArgs({
          url: 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai/users/current/accounts/accountId2',
          method: 'GET',
          headers: {
            'auth-token': token
          },
          json: true
        }).resolves({ _id: 'accountId2', region: 'us-west', primaryAccountId: 'accountId', state: 'DEPLOYED' });

        const response = await domainClient.requestMetastats(getOpts, 'accountId2');
        _sinon2.default.assert.match(response, expected);
        _sinon2.default.assert.calledWith(requestStub, {
          url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        });
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should try another region if the first failed', async () => {
        requestStub.withArgs({
          url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        }).rejects(new _errorHandler.InternalError('test'));
        requestStub.withArgs({
          url: 'https://metastats-api-v1.us-west.agiliumtrade.ai/' + 'users/current/accounts/accountId2/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        }).resolves(expected);
        const response = await domainClient.requestMetastats(getOpts, 'accountId');
        _sinon2.default.assert.calledWith(requestStub, {
          url: 'https://metastats-api-v1.us-west.agiliumtrade.ai/' + 'users/current/accounts/accountId2/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        });
        _sinon2.default.assert.match(response, expected);

        _sinon2.default.assert.calledOnce(getHostStub);
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should return error if all regions failed', async () => {
        requestStub.withArgs({
          url: 'https://metastats-api-v1.vint-hill.agiliumtrade.ai/' + 'users/current/accounts/accountId/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        }).throws(new _errorHandler.InternalError('test'));
        requestStub.withArgs({
          url: 'https://metastats-api-v1.us-west.agiliumtrade.ai/' + 'users/current/accounts/accountId2/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        }).throws(new _errorHandler.InternalError('test'));

        try {
          await domainClient.requestMetastats(getOpts, 'accountId');
          throw new Error('InternalError expected');
        } catch (error) {
          error.name.should.equal('InternalError');
        }
      });

      /**
       * @test {DomainClient#requestSignal}
       */
      it('should execute a request and update host if expired', async () => {
        const otherRegionOpts = {
          url: 'https://metastats-api-v1.us-west.agiliumtrade.ai/' + 'users/current/accounts/accountId2/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        };
        const otherRegionStub = requestStub.withArgs(otherRegionOpts).resolves(expected);
        getAccountStub = failoverRequestStub.withArgs({
          url: 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai/users/current/accounts/accountId',
          method: 'GET',
          headers: {
            'auth-token': token
          },
          json: true
        }).resolves({ _id: 'accountId', region: 'vint-hill', state: 'DEPLOYED' });
        await domainClient.requestMetastats(getOpts, 'accountId');
        await new _promise2.default(res => setTimeout(res, 50));
        _sinon2.default.assert.calledOnce(getAccountStub);
        _sinon2.default.assert.notCalled(otherRegionStub);
        getAccountStub.resolves({ _id: 'accountId2', region: 'us-west', state: 'DEPLOYED' });
        await clock.tickAsync(610000);
        const result = await domainClient.requestMetastats(getOpts, 'accountId');
        await new _promise2.default(res => setTimeout(res, 50));
        _sinon2.default.assert.calledTwice(getAccountStub);
        _sinon2.default.assert.calledOnce(otherRegionStub);
        await domainClient.requestMetastats(getOpts, 'accountId');
        await new _promise2.default(res => setTimeout(res, 50));
        _sinon2.default.assert.calledTwice(getAccountStub);
        _sinon2.default.assert.calledTwice(otherRegionStub);
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should return error if no replicas are deployed', async () => {
        getAccountStub.resolves({ _id: 'accountId', region: 'vint-hill', state: 'UNDEPLOYED' });
        try {
          await domainClient.requestMetastats(getOpts, 'accountId');
          throw new Error('ValidationError expected');
        } catch (error) {
          error.name.should.equal('ValidationError');
        }
      });

      /**
       * @test {DomainClient#requestMetastats}
       */
      it('should filter out undeployed replicas', async () => {
        getAccountStub.resolves({ _id: 'accountId', region: 'vint-hill', state: 'UNDEPLOYED', accountReplicas: [{ _id: 'accountId2', region: 'us-west', state: 'UNDEPLOYED' }, { _id: 'accountId3', region: 'germany', state: 'DEPLOYED' }] });
        requestStub.withArgs({
          url: 'https://metastats-api-v1.germany.agiliumtrade.ai/' + 'users/current/accounts/accountId3/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        }).resolves(expected);
        const response = await domainClient.requestMetastats(getOpts, 'accountId');
        _sinon2.default.assert.match(response, expected);
        _sinon2.default.assert.calledWith(requestStub, {
          url: 'https://metastats-api-v1.germany.agiliumtrade.ai/' + 'users/current/accounts/accountId3/open-trades',
          method: 'GET',
          headers: { 'auth-token': token },
          json: true
        });
      });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jbGllbnRzL2RvbWFpbi5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJkb21haW5DbGllbnQiLCJ0b2tlbiIsImh0dHBDbGllbnQiLCJIdHRwQ2xpZW50Iiwic2FuZGJveCIsInJlcXVlc3RTdHViIiwiZ2V0UmVnaW9uc1N0dWIiLCJnZXRIb3N0U3R1YiIsImZhaWxvdmVyUmVxdWVzdFN0dWIiLCJnZXRBY2NvdW50U3R1YiIsImNsb2NrIiwiZXhwZWN0ZWQiLCJ0cmFkZXMiLCJlcXVpdHkiLCJiYWxhbmNlIiwicHJvZml0IiwiZGVwb3NpdHMiLCJnZXRPcHRzIiwiaG9zdCIsImlkIiwidXJsIiwibWV0aG9kIiwiaGVhZGVycyIsImpzb24iLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJiZWZvcmVFYWNoIiwiRG9tYWluQ2xpZW50IiwidXNlRmFrZVRpbWVycyIsInNob3VsZEFkdmFuY2VUaW1lIiwic3R1YiIsIndpdGhBcmdzIiwicmVzb2x2ZXMiLCJfaWQiLCJyZWdpb24iLCJzdGF0ZSIsImFjY291bnRSZXBsaWNhcyIsImRvbWFpbiIsImFmdGVyRWFjaCIsInJlc3RvcmUiLCJvcHRzIiwiaXQiLCJyZXNwb25zZSIsInJlcXVlc3RNZXRhc3RhdHMiLCJhc3NlcnQiLCJtYXRjaCIsImNhbGxlZFdpdGgiLCJ0aWNrQXN5bmMiLCJjYWxsZWRUd2ljZSIsImNhbGxlZE9uY2UiLCJ0aHJvd3MiLCJWYWxpZGF0aW9uRXJyb3IiLCJFcnJvciIsImVycm9yIiwibmFtZSIsInNob3VsZCIsImVxdWFsIiwicmVqZWN0cyIsInByaW1hcnlBY2NvdW50SWQiLCJJbnRlcm5hbEVycm9yIiwib3RoZXJSZWdpb25PcHRzIiwib3RoZXJSZWdpb25TdHViIiwicmVzIiwic2V0VGltZW91dCIsIm5vdENhbGxlZCIsInJlc3VsdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNB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LFVBQTlDLEVBRm9HLENBQTlFLEVBQXhCO0FBSUEvQixvQkFBWTJCLFFBQVosQ0FBcUI7QUFDbkJaLGVBQUssc0RBQ0wsK0NBRm1CO0FBR25CQyxrQkFBUSxLQUhXO0FBSW5CQyxtQkFBUyxFQUFFLGNBQWNyQixLQUFoQixFQUpVO0FBS25Cc0IsZ0JBQU07QUFMYSxTQUFyQixFQU1HVSxRQU5ILENBTVl0QixRQU5aO0FBT0EsY0FBTWdDLFdBQVcsTUFBTTNDLGFBQWE0QyxnQkFBYixDQUE4QjNCLE9BQTlCLEVBQXVDLFdBQXZDLENBQXZCO0FBQ0FRLHdCQUFNb0IsTUFBTixDQUFhQyxLQUFiLENBQW1CSCxRQUFuQixFQUE2QmhDLFFBQTdCO0FBQ0FjLHdCQUFNb0IsTUFBTixDQUFhRSxVQUFiLENBQXdCMUMsV0FBeEIsRUFBcUM7QUFDbkNlLGVBQUssc0RBQ0wsK0NBRm1DO0FBR25DQyxrQkFBUSxLQUgyQjtBQUluQ0MsbUJBQVMsRUFBRSxjQUFjckIsS0FBaEIsRUFKMEI7QUFLbkNzQixnQkFBTTtBQUw2QixTQUFyQztBQU9ELE9BckJEO0FBd0JELEtBMUtEO0FBNEtELEdBN1BEO0FBK1BELENBbFVEIiwiZmlsZSI6ImRvbWFpbi5jbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnLi9odHRwQ2xpZW50JztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgRG9tYWluQ2xpZW50IGZyb20gJy4vZG9tYWluLmNsaWVudCc7XG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IsIEludGVybmFsRXJyb3IgfSBmcm9tICcuL2Vycm9ySGFuZGxlcic7XG4gXG4vKipcbiAqIEB0ZXN0IHtEb21haW5DbGllbnR9XG4gKi9cbmRlc2NyaWJlKCdEb21haW5DbGllbnQnLCAoKSA9PiB7XG4gXG4gIGxldCBkb21haW5DbGllbnQ7XG4gIGNvbnN0IHRva2VuID0gJ2hlYWRlci5wYXlsb2FkLnNpZ24nO1xuICBsZXQgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KCk7XG4gIGxldCBzYW5kYm94O1xuICBsZXQgcmVxdWVzdFN0dWI7XG4gIGxldCBnZXRSZWdpb25zU3R1YjtcbiAgbGV0IGdldEhvc3RTdHViO1xuICBsZXQgZmFpbG92ZXJSZXF1ZXN0U3R1YjtcbiAgbGV0IGdldEFjY291bnRTdHViO1xuICBsZXQgY2xvY2s7XG4gIGNvbnN0IGV4cGVjdGVkID0ge3RyYWRlczogMTAsIGVxdWl0eTogMTAxMDIuNSwgYmFsYW5jZTogMTAxMDUsIHByb2ZpdDogMTA0LCBkZXBvc2l0czogMTAwMDF9O1xuICBjb25zdCBnZXRPcHRzID0gKGhvc3QsIGlkKSA9PiAoe1xuICAgIHVybDogaG9zdCArIGAvdXNlcnMvY3VycmVudC9hY2NvdW50cy8ke2lkfS9vcGVuLXRyYWRlc2AsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgfSxcbiAgICBqc29uOiB0cnVlLFxuICB9KTtcbiBcbiAgYmVmb3JlKCgpID0+IHtcbiAgICBzYW5kYm94ID0gc2lub24uY3JlYXRlU2FuZGJveCgpO1xuICB9KTtcbiBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZG9tYWluQ2xpZW50ID0gbmV3IERvbWFpbkNsaWVudChodHRwQ2xpZW50LCB0b2tlbik7XG4gICAgY2xvY2sgPSBzYW5kYm94LnVzZUZha2VUaW1lcnMoe3Nob3VsZEFkdmFuY2VUaW1lOiB0cnVlfSk7XG4gICAgZmFpbG92ZXJSZXF1ZXN0U3R1YiA9IHNhbmRib3guc3R1YihodHRwQ2xpZW50LCAncmVxdWVzdFdpdGhGYWlsb3ZlcicpO1xuICAgIGdldEFjY291bnRTdHViID0gZmFpbG92ZXJSZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICB1cmw6ICdodHRwczovL210LXByb3Zpc2lvbmluZy1hcGktdjEuYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haS91c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZCcsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZVxuICAgIH0pLnJlc29sdmVzKHtfaWQ6ICdhY2NvdW50SWQnLCByZWdpb246ICd2aW50LWhpbGwnLCBzdGF0ZTogJ0RFUExPWUVEJywgXG4gICAgICBhY2NvdW50UmVwbGljYXM6IFtcbiAgICAgICAge19pZDogJ2FjY291bnRJZDInLCByZWdpb246ICd1cy13ZXN0Jywgc3RhdGU6ICdERVBMT1lFRCd9XG4gICAgICBdfSk7XG4gICAgcmVxdWVzdFN0dWIgPSBzYW5kYm94LnN0dWIoaHR0cENsaWVudCwgJ3JlcXVlc3QnKTtcbiAgICByZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICB1cmw6ICdodHRwczovL21ldGFzdGF0cy1hcGktdjEudmludC1oaWxsLmFnaWxpdW10cmFkZS5haS8nICtcbiAgICAgICAgJ3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkL29wZW4tdHJhZGVzJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7ICdhdXRoLXRva2VuJzogdG9rZW4gfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9KS5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgZ2V0SG9zdFN0dWIgPSBmYWlsb3ZlclJlcXVlc3RTdHViLndpdGhBcmdzKHtcbiAgICAgIHVybDogJ2h0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS5hZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpL3VzZXJzL2N1cnJlbnQvc2VydmVycy9tdC1jbGllbnQtYXBpJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pLnJlc29sdmVzKHtkb21haW46ICdhZ2lsaXVtdHJhZGUuYWknfSk7XG4gIH0pO1xuIFxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIHNhbmRib3gucmVzdG9yZSgpO1xuICAgIGNsb2NrLnJlc3RvcmUoKTtcbiAgfSk7XG4gXG4gIC8qKlxuICAgKiBAdGVzdCB7RG9tYWluQ2xpZW50I3JlcXVlc3RNZXRhc3RhdHN9XG4gICAqL1xuICBkZXNjcmliZSgncmVxdWVzdE1ldGFzdGF0cycsICgpID0+IHtcbiBcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdXJsOiAnL3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkL21ldHJpY3MnLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBAdGVzdCB7RG9tYWluQ2xpZW50I3JlcXVlc3RNZXRhc3RhdHN9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRvbWFpbkNsaWVudC5yZXF1ZXN0TWV0YXN0YXRzKGdldE9wdHMsICdhY2NvdW50SWQnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5tYXRjaChyZXNwb25zZSwgZXhwZWN0ZWQpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgocmVxdWVzdFN0dWIsIHtcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9tZXRhc3RhdHMtYXBpLXYxLnZpbnQtaGlsbC5hZ2lsaXVtdHJhZGUuYWkvJyArXG4gICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZC9vcGVuLXRyYWRlcycsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ2F1dGgtdG9rZW4nOiB0b2tlbiB9LFxuICAgICAgICBqc29uOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdfdXBkYXRlSG9zdCcsICgpID0+IHtcbiBcbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0RvbWFpbkNsaWVudCNyZXF1ZXN0TWV0YXN0YXRzfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJlcXVlc3QgdXJsIGFnYWluIGlmIGV4cGlyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGRvbWFpbkNsaWVudC5yZXF1ZXN0TWV0YXN0YXRzKGdldE9wdHMsICdhY2NvdW50SWQnKTtcbiAgICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDYxMDAwMCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG9tYWluQ2xpZW50LnJlcXVlc3RNZXRhc3RhdHMoZ2V0T3B0cywgJ2FjY291bnRJZCcpO1xuICAgICAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVzcG9uc2UsIGV4cGVjdGVkKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgocmVxdWVzdFN0dWIsIHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL21ldGFzdGF0cy1hcGktdjEudmludC1oaWxsLmFnaWxpdW10cmFkZS5haS8nICtcbiAgICAgICAgICAndXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQvb3Blbi10cmFkZXMnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnYXV0aC10b2tlbic6IHRva2VuIH0sXG4gICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFR3aWNlKGdldEhvc3RTdHViKTtcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtEb21haW5DbGllbnQjcmVxdWVzdE1ldGFzdGF0c31cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCB1c2UgY2FjaGVkIHVybCBvbiByZXBlYXRlZCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkb21haW5DbGllbnQucmVxdWVzdE1ldGFzdGF0cyhnZXRPcHRzLCAnYWNjb3VudElkJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG9tYWluQ2xpZW50LnJlcXVlc3RNZXRhc3RhdHMoZ2V0T3B0cywgJ2FjY291bnRJZCcpO1xuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChyZXF1ZXN0U3R1Yiwge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vbWV0YXN0YXRzLWFwaS12MS52aW50LWhpbGwuYWdpbGl1bXRyYWRlLmFpLycgK1xuICAgICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZC9vcGVuLXRyYWRlcycsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdhdXRoLXRva2VuJzogdG9rZW4gfSxcbiAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVzcG9uc2UsIGV4cGVjdGVkKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2UoZ2V0SG9zdFN0dWIpO1xuICAgICAgfSk7XG4gXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtEb21haW5DbGllbnQjcmVxdWVzdE1ldGFzdGF0c31cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3IgaWYgZmFpbGVkIHRvIGdldCBob3N0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZXRIb3N0U3R1Yi50aHJvd3MobmV3IFZhbGlkYXRpb25FcnJvcigndGVzdCcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBkb21haW5DbGllbnQucmVxdWVzdE1ldGFzdGF0cyhnZXRPcHRzLCAnYWNjb3VudElkJyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0aW9uRXJyb3IgZXhwZWN0ZWQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvci5uYW1lLnNob3VsZC5lcXVhbCgnVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0RvbWFpbkNsaWVudCNyZXF1ZXN0TWV0YXN0YXRzfVxuICAgICAqL1xuICAgIGRlc2NyaWJlKCdfdXBkYXRlQWNjb3VudEhvc3QnLCAoKSA9PiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0RvbWFpbkNsaWVudCNyZXF1ZXN0TWV0YXN0YXRzfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBlcnJvciBpZiBmYWlsZWQgdG8gZ2V0IGFjY291bnQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0QWNjb3VudFN0dWIucmVqZWN0cyhuZXcgVmFsaWRhdGlvbkVycm9yKCd0ZXN0JykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGRvbWFpbkNsaWVudC5yZXF1ZXN0TWV0YXN0YXRzKGdldE9wdHMsICdhY2NvdW50SWQnKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb25FcnJvciBleHBlY3RlZCcpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVycm9yLm5hbWUuc2hvdWxkLmVxdWFsKCdWYWxpZGF0aW9uRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmVxdWVzdCBtYWluIGFjY291bnQgaWYgdXNpbmcgcmVwbGljYScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZmFpbG92ZXJSZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tdC1wcm92aXNpb25pbmctYXBpLXYxLmFnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWkvdXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQyJyxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfSkucmVzb2x2ZXMoe19pZDogJ2FjY291bnRJZDInLCByZWdpb246ICd1cy13ZXN0JywgcHJpbWFyeUFjY291bnRJZDogJ2FjY291bnRJZCcsIHN0YXRlOiAnREVQTE9ZRUQnfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkb21haW5DbGllbnQucmVxdWVzdE1ldGFzdGF0cyhnZXRPcHRzLCAnYWNjb3VudElkMicpO1xuICAgICAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVzcG9uc2UsIGV4cGVjdGVkKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgocmVxdWVzdFN0dWIsIHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL21ldGFzdGF0cy1hcGktdjEudmludC1oaWxsLmFnaWxpdW10cmFkZS5haS8nICtcbiAgICAgICAgICAndXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQvb3Blbi10cmFkZXMnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnYXV0aC10b2tlbic6IHRva2VuIH0sXG4gICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtEb21haW5DbGllbnQjcmVxdWVzdE1ldGFzdGF0c31cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCB0cnkgYW5vdGhlciByZWdpb24gaWYgdGhlIGZpcnN0IGZhaWxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVxdWVzdFN0dWIud2l0aEFyZ3Moe1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vbWV0YXN0YXRzLWFwaS12MS52aW50LWhpbGwuYWdpbGl1bXRyYWRlLmFpLycgK1xuICAgICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZC9vcGVuLXRyYWRlcycsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdhdXRoLXRva2VuJzogdG9rZW4gfSxcbiAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH0pLnJlamVjdHMobmV3IEludGVybmFsRXJyb3IoJ3Rlc3QnKSk7XG4gICAgICAgIHJlcXVlc3RTdHViLndpdGhBcmdzKHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL21ldGFzdGF0cy1hcGktdjEudXMtd2VzdC5hZ2lsaXVtdHJhZGUuYWkvJyArXG4gICAgICAgICAgJ3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkMi9vcGVuLXRyYWRlcycsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdhdXRoLXRva2VuJzogdG9rZW4gfSxcbiAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH0pLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkb21haW5DbGllbnQucmVxdWVzdE1ldGFzdGF0cyhnZXRPcHRzLCAnYWNjb3VudElkJyk7XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKHJlcXVlc3RTdHViLCB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tZXRhc3RhdHMtYXBpLXYxLnVzLXdlc3QuYWdpbGl1bXRyYWRlLmFpLycgK1xuICAgICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZDIvb3Blbi10cmFkZXMnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnYXV0aC10b2tlbic6IHRva2VuIH0sXG4gICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKHJlc3BvbnNlLCBleHBlY3RlZCk7XG4gXG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGdldEhvc3RTdHViKTtcbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtEb21haW5DbGllbnQjcmVxdWVzdE1ldGFzdGF0c31cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3IgaWYgYWxsIHJlZ2lvbnMgZmFpbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tZXRhc3RhdHMtYXBpLXYxLnZpbnQtaGlsbC5hZ2lsaXVtdHJhZGUuYWkvJyArXG4gICAgICAgICAgJ3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkL29wZW4tdHJhZGVzJyxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2F1dGgtdG9rZW4nOiB0b2tlbiB9LFxuICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfSkudGhyb3dzKG5ldyBJbnRlcm5hbEVycm9yKCd0ZXN0JykpO1xuICAgICAgICByZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tZXRhc3RhdHMtYXBpLXYxLnVzLXdlc3QuYWdpbGl1bXRyYWRlLmFpLycgK1xuICAgICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZDIvb3Blbi10cmFkZXMnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnYXV0aC10b2tlbic6IHRva2VuIH0sXG4gICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICB9KS50aHJvd3MobmV3IEludGVybmFsRXJyb3IoJ3Rlc3QnKSk7XG4gXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZG9tYWluQ2xpZW50LnJlcXVlc3RNZXRhc3RhdHMoZ2V0T3B0cywgJ2FjY291bnRJZCcpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWxFcnJvciBleHBlY3RlZCcpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVycm9yLm5hbWUuc2hvdWxkLmVxdWFsKCdJbnRlcm5hbEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0ZXN0IHtEb21haW5DbGllbnQjcmVxdWVzdFNpZ25hbH1cbiAgICAgICAqL1xuICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIGEgcmVxdWVzdCBhbmQgdXBkYXRlIGhvc3QgaWYgZXhwaXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZWdpb25PcHRzID0ge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vbWV0YXN0YXRzLWFwaS12MS51cy13ZXN0LmFnaWxpdW10cmFkZS5haS8nICtcbiAgICAgICAgICAndXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQyL29wZW4tdHJhZGVzJyxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2F1dGgtdG9rZW4nOiB0b2tlbiB9LFxuICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3RoZXJSZWdpb25TdHViID0gcmVxdWVzdFN0dWIud2l0aEFyZ3Mob3RoZXJSZWdpb25PcHRzKS5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgICAgIGdldEFjY291bnRTdHViID0gZmFpbG92ZXJSZXF1ZXN0U3R1Yi53aXRoQXJncyh7XG4gICAgICAgICAgdXJsOiAgJ2h0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS5hZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpL3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvYWNjb3VudElkJyxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfSkucmVzb2x2ZXMoe19pZDogJ2FjY291bnRJZCcsIHJlZ2lvbjogJ3ZpbnQtaGlsbCcsIHN0YXRlOiAnREVQTE9ZRUQnfSk7XG4gICAgICAgIGF3YWl0IGRvbWFpbkNsaWVudC5yZXF1ZXN0TWV0YXN0YXRzKGdldE9wdHMsICdhY2NvdW50SWQnKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShnZXRBY2NvdW50U3R1Yik7XG4gICAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQob3RoZXJSZWdpb25TdHViKTtcbiAgICAgICAgZ2V0QWNjb3VudFN0dWIucmVzb2x2ZXMoe19pZDogJ2FjY291bnRJZDInLCByZWdpb246ICd1cy13ZXN0Jywgc3RhdGU6ICdERVBMT1lFRCcgfSk7XG4gICAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg2MTAwMDApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb21haW5DbGllbnQucmVxdWVzdE1ldGFzdGF0cyhnZXRPcHRzLCAnYWNjb3VudElkJyk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFR3aWNlKGdldEFjY291bnRTdHViKTtcbiAgICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2Uob3RoZXJSZWdpb25TdHViKTtcbiAgICAgICAgYXdhaXQgZG9tYWluQ2xpZW50LnJlcXVlc3RNZXRhc3RhdHMoZ2V0T3B0cywgJ2FjY291bnRJZCcpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUd2ljZShnZXRBY2NvdW50U3R1Yik7XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUd2ljZShvdGhlclJlZ2lvblN0dWIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHRlc3Qge0RvbWFpbkNsaWVudCNyZXF1ZXN0TWV0YXN0YXRzfVxuICAgICAgICovXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBlcnJvciBpZiBubyByZXBsaWNhcyBhcmUgZGVwbG95ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdldEFjY291bnRTdHViLnJlc29sdmVzKHtfaWQ6ICdhY2NvdW50SWQnLCByZWdpb246ICd2aW50LWhpbGwnLCBzdGF0ZTogJ1VOREVQTE9ZRUQnfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZG9tYWluQ2xpZW50LnJlcXVlc3RNZXRhc3RhdHMoZ2V0T3B0cywgJ2FjY291bnRJZCcpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbkVycm9yIGV4cGVjdGVkJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZXJyb3IubmFtZS5zaG91bGQuZXF1YWwoJ1ZhbGlkYXRpb25FcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdGVzdCB7RG9tYWluQ2xpZW50I3JlcXVlc3RNZXRhc3RhdHN9XG4gICAgICAgKi9cbiAgICAgIGl0KCdzaG91bGQgZmlsdGVyIG91dCB1bmRlcGxveWVkIHJlcGxpY2FzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZXRBY2NvdW50U3R1Yi5yZXNvbHZlcyh7X2lkOiAnYWNjb3VudElkJywgcmVnaW9uOiAndmludC1oaWxsJywgc3RhdGU6ICdVTkRFUExPWUVEJywgYWNjb3VudFJlcGxpY2FzOiBbXG4gICAgICAgICAge19pZDogJ2FjY291bnRJZDInLCByZWdpb246ICd1cy13ZXN0Jywgc3RhdGU6ICdVTkRFUExPWUVEJ30sXG4gICAgICAgICAge19pZDogJ2FjY291bnRJZDMnLCByZWdpb246ICdnZXJtYW55Jywgc3RhdGU6ICdERVBMT1lFRCd9XG4gICAgICAgIF19KTtcbiAgICAgICAgcmVxdWVzdFN0dWIud2l0aEFyZ3Moe1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vbWV0YXN0YXRzLWFwaS12MS5nZXJtYW55LmFnaWxpdW10cmFkZS5haS8nICtcbiAgICAgICAgICAndXNlcnMvY3VycmVudC9hY2NvdW50cy9hY2NvdW50SWQzL29wZW4tdHJhZGVzJyxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ2F1dGgtdG9rZW4nOiB0b2tlbiB9LFxuICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfSkucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRvbWFpbkNsaWVudC5yZXF1ZXN0TWV0YXN0YXRzKGdldE9wdHMsICdhY2NvdW50SWQnKTtcbiAgICAgICAgc2lub24uYXNzZXJ0Lm1hdGNoKHJlc3BvbnNlLCBleHBlY3RlZCk7XG4gICAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKHJlcXVlc3RTdHViLCB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tZXRhc3RhdHMtYXBpLXYxLmdlcm1hbnkuYWdpbGl1bXRyYWRlLmFpLycgK1xuICAgICAgICAgICd1c2Vycy9jdXJyZW50L2FjY291bnRzL2FjY291bnRJZDMvb3Blbi10cmFkZXMnLFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnYXV0aC10b2tlbic6IHRva2VuIH0sXG4gICAgICAgICAganNvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG5cbiAgICB9KTtcblxuICB9KTtcblxufSk7XG4gIl19